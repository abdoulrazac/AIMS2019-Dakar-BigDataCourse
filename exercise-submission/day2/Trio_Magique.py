{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "\"\"\"\n",
    "GENERAL INSTRUCTIONS\n",
    "WARNING: For Python beginners:\n",
    "the instructions here will only make sense after you have gone through and\n",
    "completed the training materials.\n",
    "1. WHICH PART TO CHANGE?: Uncomment every line with  [YOUR CODE HERE] and replace it with your code.\n",
    "Please don't change anything else other than these lines.\n",
    "2. USE OF JUPYTER NOTEBOOK: For those who would like to use Jupyter Notebook. You can copy and paste\n",
    "each function in the notebook environment, test your code their. However,\n",
    "remember to paste back your code in a .py file and ensure that its running\n",
    "okay.\n",
    "3. IDENTATION: Please make sure that you check your identation\n",
    "4. Returning things frm function: All the functions below have to return a value.\n",
    "Please dont forget to use the return statement to return a value.\n",
    "5. HINTS: please read my comments for hints and instructions where applicable\n",
    "6. DEFINING YOUR OWN FUNCTIONS: where I ask you to define your own function\n",
    "please make sure that you name the function exactly as I said.\n",
    "\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# import Python libraries if required\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "from matplotlib import pyplot as plt\n",
    "from textblob import TextBlob\n",
    "import nltk\n",
    "import requests\n",
    "from bs4 import BeautifulSoup\n",
    "\n",
    "# define a function, please call it: report_basic_data_properties\n",
    "# the function should take as input a CSV file, call the input\n",
    "# parameter \"csv_file\"\n",
    "# and return the following properties about the data\n",
    "# 1. Number of rows in the data\n",
    "# 2. List of column names\n",
    "# Note that you can return two values in a function\n",
    "# using a tuple\n",
    "def report_basic_data_properties(csv_file):\n",
    "    data=pd.read_csv(csv_file)\n",
    "    return (data.shape[0], list(data.columns))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_name_of_town_with_highest_elevation(csv_file=None, elev_col=\"elev_metres\"):\n",
    "    \"\"\"\n",
    "    Given the following data file: day2-python-for-data-science/data/townships_with_dist_and_elev.csv\n",
    "    return the town with highest elevation.\n",
    "    Note that column name with elevation values is already provided as a default parameter.\n",
    "    :param csv_file: CSV file with elevation data\n",
    "    :param elev_col: Column with elevation values\n",
    "    :return: town name with highest elevation value\n",
    "    \"\"\"\n",
    "    # read data into pandas dataframe\n",
    "    data=pd.read_csv(csv_file)\n",
    "\n",
    "    # get the maximum value for elev_metres column\n",
    "    max_elev_metres=max(data[elev_col])\n",
    "\n",
    "    # inspect the object type which you get above\n",
    "    # if its a series object use the function\n",
    "    # \"values\" on it like so: pd_series.values\n",
    "    # in order to get a string\n",
    "    # [YOUR CODE HERE]\n",
    "    \n",
    "    # return the answer\n",
    "    # [YOUR CODE HERE]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "float"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "path='./data/townships_with_dist_and_elev.csv'\n",
    "data=pd.read_csv(path)\n",
    "max_elev_metres=max(data[\"elev_metres\"])\n",
    "type(max_elev_metres)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_a_numeric_attribute(csv_file=None, col_to_plot=None, output_plot=None):\n",
    "    \"\"\"\n",
    "    Given a CSV file, read the data using pandas, plot a given column\n",
    "    and finally save the plot as \"png\" file.\n",
    "    DATA FOR TESTING: day2-python-for-data-science/data/townships_with_dist_and_elev.csv\n",
    "    COLUMN NAME FOR TESTING: 'elev_meters' column\n",
    "    :param csv_file: File to get data from\n",
    "    :param col_to_plot: Column name to plot\n",
    "    :param output_plot: Save output plot to file\n",
    "    :return:\n",
    "    \"\"\"\n",
    "\n",
    "    # read data into pandas dataframe\n",
    "    data=pd.read_csv(csv_file)\n",
    "\n",
    "    # use seaborn to plot distribution of data\n",
    "    ax = sns.distplot(data[col_to_plot])\n",
    "\n",
    "    # save plot as png file\n",
    "    ax.get_figure().savefig(output_plot)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "def translate_to_french_for_dunstan(sentence=None):\n",
    "    \"\"\"\n",
    "    Given a sentence, translate each word in the sentence\n",
    "    Example: sentence = 'I love you', returns {\"I\": \"je\", \"love\": \"amour\", \"you\": \"vous\"}\n",
    "    use textblob package (https://textblob.readthedocs.io/en/dev/) and NLTK package\n",
    "    for this task\n",
    "    :param sentence: Sentence to translate\n",
    "    :return: a dictionary where key is english word and value is translated french word\n",
    "    \"\"\"\n",
    "    #nltk.download('punkt') --> to be done once\n",
    "    # first tokenize the words: split the sentence\n",
    "    # into words using the NLTK function word_tokenize()\n",
    "    words =nltk.word_tokenize(sentence)\n",
    "\n",
    "    # initiate a dictionary object to put in english and French words\n",
    "    en_fr = {}\n",
    "\n",
    "    # Now do the translation\n",
    "    for w in words:\n",
    "        en_blob = TextBlob(w)\n",
    "    #\n",
    "    #     # use the function translate(from_lang=\"en\", to='fr')\n",
    "    #     # on the en_blob object defined above\n",
    "        fr_blob = en_blob.translate(from_lang=\"en\", to='fr')\n",
    "    #\n",
    "    #     # use function raw on the blob above to get the word as a string\n",
    "        fr_blob=str(fr_blob)\n",
    "    #\n",
    "    #     # put the translated word in the\n",
    "    #     # dictionary object en_fr with english\n",
    "    #     # as key and corresponding french translation as value\n",
    "        en_fr[w]=fr_blob\n",
    "\n",
    "    return en_fr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_table_rows_from_webpage(url=None):\n",
    "    \"\"\"\n",
    "    The function should go to the webpage given in the parameter\n",
    "    extract the table values and save to CSV file\n",
    "    :param url: The website to get the table from\n",
    "    :return:\n",
    "    \"\"\"\n",
    "\n",
    "    # Open the website using requests, retrieve HTML and create BS object\n",
    "    response = requests.get(url)\n",
    "    html = response.text\n",
    "    bs = BeautifulSoup(html, 'lxml')\n",
    "\n",
    "    # Now get all table rows using the tr tag\n",
    "    tb_rows = bs.find_all('tr')\n",
    "\n",
    "    # return the table rows\n",
    "    return tb_rows"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "def clean_table_rows(tb_rows=None):\n",
    "    \"\"\"\n",
    "    Since \n",
    "    :param tb_rows:\n",
    "    :return:\n",
    "    \"\"\"\n",
    "\n",
    "    # Declare list to hold all cleaned rows\n",
    "    cleaned_rows = []\n",
    "\n",
    "    for row in tb_rows:\n",
    "    #     # Extract cell using table cell HTML tag\n",
    "        cells = row.find_all(\"td\")\n",
    "    #\n",
    "    #     # Extract text only\n",
    "        str_cells = str(cells)\n",
    "        clean_text = BeautifulSoup(str_cells, \"lxml\").get_text()\n",
    "    #\n",
    "    #     # Remove white spaces-a little convuluted but it works\n",
    "        clean_text2 = \" \".join(clean_text.split())\n",
    "    #\n",
    "    #     # Remove brackts at beginning and end\n",
    "        clean_text3 = clean_text2[1:-1]\n",
    "    #\n",
    "    #     # Split clean_text3 using comma delimiter\n",
    "        split_str = clean_text3.split(\",\")\n",
    "    #\n",
    "    #\n",
    "    #     # Remove white spaces again\n",
    "        split_str2 = [i.strip() for i in split_str]\n",
    "    #\n",
    "    #     # Add split_str2 to cleaned_rows list\n",
    "        cleaned_rows.append(split_str2)\n",
    "\n",
    "    # return cleaned rows\n",
    "    return cleaned_rows"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "def convert_website_table_to_csv():\n",
    "    \"\"\"\n",
    "    The function scrapes data off the website wih given url\n",
    "    and saves it into CSV file.\n",
    "    :param output_csv_file:\n",
    "    :return:\n",
    "    \"\"\"\n",
    "    # URL to get data from\n",
    "    URL = 'https://www.tcsnycmarathon.org/about-the-race/results/overall-men'\n",
    "\n",
    "    # extract table rows using the function \"get_table_rows_from_webpage\"\n",
    "    #  defined above\n",
    "    tb_rows =  get_table_rows_from_webpage(URL)\n",
    "\n",
    "    # clean up table rows using \"clean_table_rows\" function\n",
    "    clean_tb_rows =  clean_table_rows(tb_rows)\n",
    "\n",
    "    # Column names: note that the first element of the list contains the column names\n",
    "    # Use list indexing to get the column headers\n",
    "    colnames = clean_tb_rows[0]\n",
    "\n",
    "    # Create dataframe\n",
    "    df_men = pd.DataFrame(data=clean_tb_rows[1:], columns=colnames)\n",
    "\n",
    "    # save the dataframe to CSV file\n",
    "    df_men.to_csv(output_csv_file, index=False)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_weather(api_key=None, city_id=None):\n",
    "    \"\"\"\n",
    "    Returns weather\n",
    "    :param api_key:\n",
    "    :param city_name:\n",
    "    :return:\n",
    "    \"\"\"\n",
    "    # add your API key\n",
    "    url = \"http://api.openweathermap.org/data/2.5/forecast?id={}&APPID={}\".format(city_id,api_key)\n",
    "\n",
    "    # use requests to retrieve data from the API\n",
    "    r=requests.get(url)\n",
    "\n",
    "    # retrieve JSON from the response object\n",
    "    r_json=r.json()\n",
    "\n",
    "    # return the JSON object\n",
    "    return r_json"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [],
   "source": [
    "def compile_weather_forecast(city_name=None, output_csv_file=None):\n",
    "    \"\"\"\n",
    "    Get weather forecasts for Dakar. Please get only TEMPERATURE and HUMIDITY\n",
    "    Useful Info:\n",
    "    city_details_file: day2-python-for-data-science/data/city.list.json\n",
    "    :param your_api_key:\n",
    "    :param output_csv_file:\n",
    "    :return:\n",
    "    \"\"\"\n",
    "    # # copy and paste your API key below\n",
    "    API_KEY = 'a8640550baf72d4de139447630d523ee'\n",
    "    #\n",
    "    # # JSON file with city details\n",
    "    jfile = '../data/city.list.json'\n",
    "    #\n",
    "    # # load city details file\n",
    "    f=open(jfile, encoding=\"utf8\")\n",
    "    data = json.load(f)\n",
    "    #\n",
    "    # # inspect the data object above\n",
    "    # # use for loop and if statement to find city id\n",
    "    city_code = None\n",
    "    for city in data:\n",
    "        if city[\"name\"]==city_name:\n",
    "            city_code=city[\"id\"]\n",
    "            break\n",
    "    #\n",
    "    # # now get the weather forecast using the\n",
    "    # # \"get_weather\" function defined above\n",
    "    weather_json = get_weather(api_key=API_KEY, city_id=city_code)\n",
    "    #\n",
    "    # # using method for accessing a dictionary\n",
    "    # # put weather items in a list\n",
    "    weather_items = weather_json['list']\n",
    "\n",
    "    #\n",
    "    # # save into a dataframe\n",
    "    data = []  # will hold our data\n",
    "    #\n",
    "    for item in weather_items:\n",
    "    #     # get forecast time\n",
    "        ts = item['dt']\n",
    "    #\n",
    "    #     # get temperature, rain and humidity\n",
    "        temp = item['temp_min']\n",
    "        hum = item['humidity']\n",
    "    #\n",
    "    #     # for rains and clouds, use get() method to\n",
    "    #     # retrieve required values\n",
    "    #     rains = [YOUR CODE HERE]\n",
    "    #\n",
    "    #     clouds = [YOUR CODE HERE]\n",
    "    #\n",
    "    #     data_item = {'forecastTime': [YOUR CODE HERE], 'tempF': [YOUR CODE HERE],\n",
    "    #                  'humidity': [YOUR CODE HERE], \"rain\": [YOUR CODE HERE],\n",
    "    #                  'cloudsPercent': [YOUR CODE HERE]}\n",
    "    #\n",
    "    #     # append to list of create earlier on\n",
    "    #     [YOUR CODE HERE]\n",
    "    #\n",
    "\n",
    "    # # create dataframe\n",
    "    # [YOUR CODE HERE]\n",
    "    # \n",
    "    # # save dataframe with option index set to False\n",
    "    # [YOUR CODE HERE]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
